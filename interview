一、c++:
1. explicit关键字的使用：被explicit关键字修饰的构造函数，不能进行自动隐式类型转换，只能显式进行类型转换。
	注意：只有一个参数的构造函数，或者构造函数有n个参数，但有n-1个参数提供了默认值，这样的情况才能进行类型转换。
2. PostMessage: 异步发送消息到消息队列后立即返回，想象一下邮筒；
   SendMessage:	同步发送消息到指定窗口，等待处理后才返回；
3. 进程间通讯种类：管道、信号量、共享内存、套接字、消息队列(克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点)。
4. 线程间通讯种类：信号机制、信号量机制、锁机制(条件变量、互斥锁、读写锁、自旋锁)
5. vector/list区别：vector与数组类似，拥有一段连续的内存空间，并且起始地址不变；list底层是由双向链表实现的，因此内存空间不是连续的。
6. 强制类型转换函数操作符：
	1)static_cast < type-id > ( exdivssion )：该运算符把exdivssion转换为type-id类型，但没有运行时类型检查来保证转换的安全性；
					常用于基类和子类之间指针或引用的转换、基本类型之间的转换；
	2)dynamic_cast < type-id > ( exdivssion )：安全的向下转型，即基类指针/引用转继承类指针/引用；
				一种是基类指针所指对象是派生类类型的，这种转换是安全的；
				另一种是基类指针所指对象为基类类型，在这种情况下dynamic_cast在运行时做检查，转换失败
	3)reinterpret_cast:用在任意指针/引用类型之间的转换；以及指针与足够大的整数类型之间的转换,强制编译器接受static_cast通常不允许的类型转换.
	4)const_cast:常量指针/引用被转化成非常量指针/引用，并且仍然指向原来的对象；用来改变表达式里面的常量性（const）或易变性（volatile）；
	

7. const不同位置的作用：
		函数后面加 const，表示函数不可以修改class的成员;
		
8. 继承类在构造/析构函数中的执行顺序：
	构造函数执行顺序：继承类先执行父类中的构造函数，然后再执行自己的构造函数（先有父亲再有儿子）；
	析构函数执行顺序：先执行继承类自己的析构函数，然后再执行父类的析构函数（儿子不行了老子再上）。

二、HTTP相关通讯协议
1. OSI的7层协议：物理层(bit流，代表设备:集线器/调制解调器);
				数据链路层(byte流/数据帧)；
				网络层(数据包，通过路由实现数据在不同网络之间的传输，好比邮政服务，不知对方是否收到、是否有人读过)；
				传输层(TCP/UDP，为上层协议提供端到端的可靠和透明的数据传输服务)；
				会话层(负责建立、管理和终止表示层实体之间的通信会话);
				表示层(提供各种用于应用层数据的编码和转换功能,以及数据的加解密)；
				应用层(为用户提供各种应用接口及网络协议，如HTTP，HTTPS，FTP，POP3、SMTP)。
				
2.UDP多播（Multicasting）：在同一时间把一个数据包发送到多个、甚至是未知的设备。只有UDP有多播或广播，消息只是先发送到一个多播地址，网络将数据分发给哪些表示想要接收发送到该多播地址的数据的主机。类似回调函数的注册，只有注册了的对象才能收到回调通知。应用如网络会议。广域网多播的地址是特定的，D类地址用于多播。D类IP地址就是多播IP地址，即224.0.0.0至239.255.255.255之间的IP地址，并被划分为局部连接多播地址、预留多播地址和管理权限多播地址3类。
（1）建立一个socket；
（2）然后设置多播的参数，例如超时时间TTL、本地回环许可LOOP等；
（3）加入多播组；
（4）发送和接收数据；
（5）从多播组离开。
server：建立socket;设置参数,224.0.0.88/port；whele()循环中sendto();
client: 建立socket;设置参数；bind端口；whele()循环中recvfrom()。
		设置参数包括：
		setsockopt(sock,IPPROTO_IP,IP_MULTICAST_LOOP,&loop,sizeof(loop));	//设置回环许可
		setsockopt(sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,&mreq,sizeof(mreq));	//加入多播组
		setsockopt(sock,IPPROTO_IP,IP_DROP_MEMBERSHIP,&mreq,sizeof(mreq));	//退出whele循环后，调用退出多播组

3.广播(Broadcast)：网络中的所有系统都能收到，类似发布/订阅？使用广播地址255.255.255.255，同时要指明接收者的端口号的，因为不可能接受者的所有端口都来收听广播。另外，本地广播信息是不会被路由器转发到广域网里的。
（1）server：建立socket;设置参数,255.255.255.255/port以及广播属性；whele()循环中sendto();
（2）client: 建立socket;设置参数；bind端口；whele()循环中recvfrom();

三、db
	锁机制
	表索引数据结构B+树
		索引回表：主键索引的叶子节点存放的是整行数据，非主键索引的叶子节点存放的是主键值。所以如果以主键查询的方式，只需要搜索主键这颗B+树，而以非主键查询数据库，则先搜索非主键的索引树，得到主键值，然后再到主键索引树搜索一次，这个过程称为回表；
		索引覆盖
		最左匹配：索引是有序的，所有满足条件的人都会聚集在一起。我们找到第一个满足条件的人之后，直接向右遍历就可以了。这种定位到最左边，然后向右遍历寻找，就是我们所说的最左前缀原则；
		B+树优势：哈希表做索引，无法支持模糊查找、范围查找，只能做遍历；
		索引下推
		索引优化
		
	存储过程：减少网络IO?
	事务：原子操作，所有命令要么全部执行、要么都不执行；
	
1. redis(memcached替代者，10万次读写/s) 
	（1）key-value存储系统，value类型相对更多，包括string(字符串，最大512m)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash；
			list类型作用：本质是一个FIFO双向链表，可以实现一个轻量级高性能的消息队列；
			set/zset类型作用：可以做一个排行榜、计数器；
	（2）实现了发布/订阅机制；	（3）持久化：将内存数据的快照定期更新到硬盘的操作。数据都缓存在内存中，周期性的把更新数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步；
	
		持久化的关键是这三条指令：SAVE、 BGSAVE、 LASTSAVE 
		SAVE--同步保存操作，Redis就会将当前实例的所有数据快照(snapshot)dump到dump.rdb文件里面；
		BGSAVE--background异步保存操作，fork出一个新子进程，原来的Redis进程继续处理客户端请求，而子进程则负责将数据保存到磁盘后退出；
		LASTSAVE--返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示
	（4）两种文件格式：全量数据和增量请求
		全量数据--是把内存中的数据写入磁盘，便于下次读取文件进行加载；
		增量请求--是把内存中的数据序列化为操作请求，用于读取文件进行replay得到数据，序列化的操作包括SET、RPUSH、SADD、ZADD。
		
2. mysql:所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。RDBMS 即关系数据库管理系统。
	1)联合查询：Left Join / Right Join /inner join相关：左连接where条件只影响右表，右连接where条件只影响左表。
	如：select * from tbl1 Left Join tbl2 where tbl1.ID = tbl2.ID，
				左连接后的检索结果：从tbl2入手，显示tbl1、tbl2中满足条件的所有行记录，最后加上tbl1中那些不满足条件的行(空记录)。
		select * from tbl1 Right Join tbl2 where tbl1.ID = tbl2.ID，
				右连接后的检索结果: 从tbl1入手，显示tbl1、tbl2中满足条件的所有行记录，最后加上tbl2中那些不满足条件的行(空记录)。
		select * FROM tbl1 INNER JOIN tbl2 ON tbl1.ID = tbl2.ID，功能和 select * from tbl1,tbl2 where tbl1.id=tbl2.id相同。
		
		在使用 left jion 时，on 和 where 条件的区别如下：
		1、 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。
		2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。条件不为真的就全部过滤掉。
	2)distinct：仅用于select语句，一般是用来去除查询结果中的重复记录的；
	
3. influxDb:时序数据库，用作涉及大量时间戳数据的后端存储。

四、网络库模型
1. ACE
	底层为OS适配层；二层是wrap打包类；三层是框架类(Acceptor, Connector, Reactor); 顶层是框架服务；
   功能包含网络服务、日志、IPC、线程、共享内存、配置服务等；

2. boots::asio跨平台、异步I/O、网络库
	底层为OS适配层；二层是模板类；三层是模板类的参数化(TCP/UDP)；顶层是服务io_service;
	核心类io_service，它负责和操作系统打交道，等待某异步IO操作结束，触发其回调处理程序。
	io_service.post()提交要做的事情；
	io_service.run()启动服务；
	write/write_more区别
	
	
3. EPOLL：用于linux平台，异步I/O网络库。如果IO读写状态发生了变化，用户会收到epoll_wait的通知，不负责IO操作。
  采用io多路复用技术，信号驱动，不必轮询所有的链接。仅仅是一个异步事件的通知机制，其本身并不作任何的IO读写操作，它只负责告诉你哪个socket是不是可以读或可以写了，而具体的读写操作，还要应用层自己来作。如果想进行IO操作时，先向epoll查询是否可读或可写，如果处于可读或可写状态后，epoll会通过epoll_wait函数通知你，此时你再进行进一步的recv或send操作。查询的过程，就是把当前进程通过epoll放到内核的读写队列中，如果有事件发生，内核会通过epoll_wait回调当前进程。
	水平触发LT：如果用户在监听epoll事件，当内核有事件的时候，会拷贝给用户态事件，但是如果用户只处理了一次，那么剩下没有处理的会在下一次
epoll_wait再次返回该事件。这样如果用户永远不处理这个事件，就导致每次都会有该事件从内核到用户的拷贝，耗费性能，但是水平触发相对安全，最起码事件不会丢掉，除非用户处理完毕。

	边缘触发ET：当内核有事件到达，只会通知用户一次，至于用户处理还是不处理，以后将不会再通知。这样减少了拷贝过程，增加了性能，但是
相对来说，如果用户马虎忘记处理，将会产生事件丢的情况。

4. IOCP：用于windows平台，异步I/O网络库。把IO读写操作完成后通知用户IO读写状态发生了变化。
	侦听socket轮询连接请求，将新请求压入完成端口的IO处理的LIFO栈；
    工作线程处理后，会将完成后的IO请求压入完成端口的FIFO队列，供应用层处理。
	
5. TCP:
	建立连接：服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到从accept()返回。
	断开连接：任何一方发出FIN段，另一方返回ACK。read()返回0就表明收到了FIN段。

6. UDP:
	server:socket()、bind()、recvfrom()、sendto()、close()
	client:socket()、sendto()、recvfrom()、close()
7. LibEvent:
	
五、linux
	启动防火墙：重启后生效chkconfig iptables on/off；即时生效service iptables start/stop
	查询网卡状态：ip addr

六、进程间通讯IPC: 
 1. 管道(有名mkfifo/无名)；单向传输、同步等待；
 2. 消息队列：优点，异步，克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点；
			  不足：大文件且频繁使用时，拷贝过程花费时间多；
 3. 共享内存：优点：能够解决拷贝所花费时间；不足：多进程/线程竞争内存导致的安全及效率问题；
 4. 信号量：相当于计数器，实现进程之间的互斥与同步；
 5. socket：网间通信(tcp/udp/http); 同台设备中面向连接通信UNIX domain

七、锁机制
	条件变量、互斥锁、读写锁、自旋锁
  
八. 数据结构算法
	栈、队列、链表、二叉树、图、排序算法、递归、动态规划、分治、回溯等
	
九、设计模式
	
十、git应用
	1. git clone: 第一次从远程仓库拉取代码到本地仓库;
	2. git fetch: 从远程仓库拉取更新的部分到本地仓库；
	3. git merge: 从本地仓库拉取代码，合并到工作区；
	4. git pull: 作用=(fetch+merge),从远程仓库直接拉取代码到工作区；
	5. git checkout: 工作区版本切换；
	6. git add：  工作区代码提交到暂存区；
	7. git commit: 暂存区代码提交到本地仓库；
	8. git push：  本地仓库代码提交到远程仓库；
	
十一、安全
防止4种行为：
 窃听——加密
   共享密钥对称加密：AES、DES、3DES算法
        问题：密钥分配，解决方法包括“公开密钥加密”、“密钥交互协议”等；
   公开密钥非对称加密:公开密钥用于加密，私钥用于解密，常用算法包括RAS,支付宝的椭圆曲线加密等
        问题：公钥可靠性，用数字证书解决；比较耗时，考虑混合加密解决；
   混合加密：数据加解密用对称加密，共享密钥的分配，通过非对称加密发送给对方；
   
 篡改——消息认证码/数字签名
 假冒——消息认证码/数字签名
 否认——数字签名，其中数字证书用来解决“无法确认公开密钥的制作者”问题	
